"""
Brownian Motion Test Program
This program is designed to verify whether the price curves generated by main_OHLC_2.0.5.1.py exhibit the characteristics of Brownian motion (also known as a Wiener process). Brownian motion has the following key properties:
1.	Returns (price changes) follow a normal distribution
2.	Returns are independent (no autocorrelation)
3.	Variance grows linearly with time
4.	Satisfies the random walk hypothesis
Testing Methods
1.	Normality Tests
    o	Shapiro-Wilk test
    o	Jarque-Bera test
    o	QQ plot (quantile-quantile plot)
2.	Autocorrelation Tests
    o	Autocorrelation function (ACF)
    o	Ljung-Box test
3.	Variance Growth Test
    o	Analyze variance at different time scales
4.	Random Walk Hypothesis Test
    o	Augmented Dickey-Fuller test (ADF)


"""

import numpy as np
import matplotlib.pyplot as plt
import math
from collections import defaultdict
from scipy import stats
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, acf
from statsmodels.stats.diagnostic import lilliefors
import seaborn as sns
# Note: We don't directly import functions from main_OHLC_2.0.5.1.py, but import them at runtime

class BrownianMotionTest:
    """Brownian Motion Characteristics Test Class"""

    def __init__(self, price_data, title="Price Series"):
        """
        Initialize the test class

        Parameters:
            price_data: Price time series data
            title: Data title, used for chart display
        """
        self.price_data = np.array(price_data)
        self.title = title
        # Calculate log returns
        self.log_returns = np.diff(np.log(self.price_data))
        # Calculate simple returns
        self.simple_returns = np.diff(self.price_data) / self.price_data[:-1]

    def plot_price_series(self):
        """Plot price time series"""
        plt.figure(figsize=(12, 6))
        plt.plot(self.price_data)
        plt.title(f"{self.title} - Price Series")
        plt.xlabel("Time")
        plt.ylabel("Price")
        plt.grid(True)
        plt.show()

    def plot_returns(self):
        """Plot returns distribution"""
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))

        # Log returns histogram and density plot
        sns.histplot(self.log_returns, kde=True, ax=ax1)
        ax1.set_title(f"{self.title} - Log Returns Distribution")
        ax1.set_xlabel("Log Returns")
        ax1.set_ylabel("Frequency")

        # Simple returns histogram and density plot
        sns.histplot(self.simple_returns, kde=True, ax=ax2)
        ax2.set_title(f"{self.title} - Simple Returns Distribution")
        ax2.set_xlabel("Simple Returns")
        ax2.set_ylabel("Frequency")

        plt.tight_layout()
        plt.show()

    def normality_test(self):
        """
        Normality test

        Returns:
            dict: Contains results of various normality tests
        """
        results = {}

        # Shapiro-Wilk test
        shapiro_test = stats.shapiro(self.log_returns)
        results['shapiro_statistic'] = shapiro_test[0]
        results['shapiro_p_value'] = shapiro_test[1]

        # Jarque-Bera test
        jb_test = stats.jarque_bera(self.log_returns)
        results['jb_statistic'] = jb_test[0]
        results['jb_p_value'] = jb_test[1]

        # Lilliefors test (Kolmogorov-Smirnov variant)
        try:
            ks_test = lilliefors(self.log_returns)
            results['lilliefors_statistic'] = ks_test[0]
            results['lilliefors_p_value'] = ks_test[1]
        except:
            results['lilliefors_statistic'] = None
            results['lilliefors_p_value'] = None

        # Calculate skewness and kurtosis
        results['skewness'] = stats.skew(self.log_returns)
        results['kurtosis'] = stats.kurtosis(self.log_returns)  # Excess kurtosis

        return results

    def plot_qq(self):
        """Plot QQ graph to test normality"""
        plt.figure(figsize=(10, 8))

        # QQ plot
        sm.qqplot(self.log_returns, line='s', ax=plt.gca())
        plt.title(f"{self.title} - QQ Plot of Log Returns")
        plt.grid(True)
        plt.show()

    def autocorrelation_test(self, lags=40):
        """
        Autocorrelation test

        Parameters:
            lags: Number of lags

        Returns:
            dict: Contains autocorrelation test results
        """
        results = {}

        # Calculate autocorrelation coefficients
        acf_values = acf(self.log_returns, nlags=lags)
        results['acf_values'] = acf_values

        # Ljung-Box test
        lb_test = sm.stats.acorr_ljungbox(self.log_returns, lags=[lags])
        results['lb_statistic'] = lb_test.iloc[0, 0]
        results['lb_p_value'] = lb_test.iloc[0, 1]

        return results

    def plot_autocorrelation(self, lags=40):
        """Plot autocorrelation function graph"""
        plt.figure(figsize=(12, 6))

        # Calculate autocorrelation coefficients
        acf_values = acf(self.log_returns, nlags=lags)

        # Plot autocorrelation function
        plt.stem(range(len(acf_values)), acf_values)
        plt.axhline(y=0, linestyle='-', color='black')

        # Add 95% confidence interval
        conf_level = 1.96 / np.sqrt(len(self.log_returns))
        plt.axhline(y=conf_level, linestyle='--', color='red')
        plt.axhline(y=-conf_level, linestyle='--', color='red')

        plt.title(f"{self.title} - Autocorrelation Function of Log Returns")
        plt.xlabel("Lag")
        plt.ylabel("Autocorrelation")
        plt.grid(True)
        plt.show()

    def variance_time_test(self, max_lag=20):
        """
        Variance growth over time test

        Parameters:
            max_lag: Maximum time scale

        Returns:
            dict: Contains variance-time relationship results
        """
        results = {}

        # Calculate variance at different time scales
        time_scales = range(1, max_lag + 1)
        variances = []

        for scale in time_scales:
            # Aggregate returns
            if scale == 1:
                aggregated_returns = self.log_returns
            else:
                # Group returns and sum them
                n_groups = len(self.log_returns) // scale
                aggregated_returns = np.array([
                    np.sum(self.log_returns[i*scale:(i+1)*scale])
                    for i in range(n_groups)
                ])

            # Calculate variance and normalize
            variances.append(np.var(aggregated_returns) / scale)

        results['time_scales'] = time_scales
        results['variances'] = variances

        # 线性回归分析方差与时间的关系
        slope, intercept, r_value, p_value, std_err = stats.linregress(
            np.log(time_scales), np.log(variances)
        )

        results['slope'] = slope
        results['intercept'] = intercept
        results['r_squared'] = r_value ** 2
        results['p_value'] = p_value

        # 布朗运动的理论斜率应为1，计算与理论值的偏差
        results['deviation_from_theory'] = abs(slope - 1.0)

        return results

    def plot_variance_time(self, max_lag=20):
        """Plot variance-time relationship graph"""
        results = self.variance_time_test(max_lag)

        plt.figure(figsize=(12, 6))

        # Plot variance vs time scale relationship (log-log coordinates)
        plt.loglog(results['time_scales'], results['variances'], 'o-')

        # Add fitting line
        x_fit = np.linspace(min(results['time_scales']), max(results['time_scales']), 100)
        y_fit = np.exp(results['intercept']) * x_fit ** results['slope']
        plt.loglog(x_fit, y_fit, 'r--', label=f'Slope = {results["slope"]:.4f}, R² = {results["r_squared"]:.4f}')

        # Add theoretical line (slope = 1)
        y_theory = np.exp(results['intercept']) * x_fit ** 1.0
        plt.loglog(x_fit, y_theory, 'g--', label='Theoretical (Slope = 1.0)')

        plt.title(f"{self.title} - Variance vs Time Scale (Log-Log)")
        plt.xlabel("Time Scale (Log)")
        plt.ylabel("Normalized Variance (Log)")
        plt.legend()
        plt.grid(True)
        plt.show()

    def random_walk_test(self):
        """
        Random walk hypothesis test (unit root test)

        Returns:
            dict: Contains ADF test results
        """
        results = {}

        # Augmented Dickey-Fuller test
        adf_test = adfuller(self.price_data)

        results['adf_statistic'] = adf_test[0]
        results['adf_p_value'] = adf_test[1]
        results['critical_values'] = adf_test[4]
        results['is_random_walk'] = adf_test[1] > 0.05  # p-value > 0.05 means we cannot reject the unit root hypothesis, i.e., it follows a random walk

        return results

    def hurst_exponent(self, max_lag=20):
        """
        Calculate Hurst exponent

        Parameters:
            max_lag: Maximum time scale

        Returns:
            float: Hurst exponent
        """
        # Calculate Hurst exponent using variance-time relationship slope
        variance_results = self.variance_time_test(max_lag)
        slope = variance_results['slope']

        # Relationship between Hurst exponent and slope: H = slope/2 + 0.5
        hurst = slope / 2 + 0.5

        return hurst

    def run_all_tests(self, max_lag=20):
        """
        Run all Brownian motion characteristic tests

        Parameters:
            max_lag: Maximum time scale

        Returns:
            dict: Dictionary containing all test results
        """
        results = {}

        # 1. Normality test
        results['normality'] = self.normality_test()

        # 2. Autocorrelation test
        results['autocorrelation'] = self.autocorrelation_test(lags=max_lag)

        # 3. Variance-time relationship test
        results['variance_time'] = self.variance_time_test(max_lag=max_lag)

        # 4. Random walk test
        results['random_walk'] = self.random_walk_test()

        # 5. Hurst exponent
        results['hurst_exponent'] = self.hurst_exponent(max_lag=max_lag)

        return results

    def print_results(self, results=None):
        """Print test results"""
        if results is None:
            results = self.run_all_tests()

        print(f"\n===== {self.title} - Brownian Motion Test Results =====\n")

        # 1. Normality test results
        print("1. Normality Tests:")
        print(f"   Shapiro-Wilk Test: statistic={results['normality']['shapiro_statistic']:.4f}, p-value={results['normality']['shapiro_p_value']:.6f}")
        print(f"   Jarque-Bera Test: statistic={results['normality']['jb_statistic']:.4f}, p-value={results['normality']['jb_p_value']:.6f}")
        if results['normality']['lilliefors_p_value'] is not None:
            print(f"   Lilliefors Test: statistic={results['normality']['lilliefors_statistic']:.4f}, p-value={results['normality']['lilliefors_p_value']:.6f}")
        print(f"   Skewness: {results['normality']['skewness']:.4f}")
        print(f"   Excess Kurtosis: {results['normality']['kurtosis']:.4f}")

        # 2. Autocorrelation test results
        print("\n2. Autocorrelation Tests:")
        print(f"   Ljung-Box Test: statistic={results['autocorrelation']['lb_statistic']:.4f}, p-value={results['autocorrelation']['lb_p_value']:.6f}")

        # 3. Variance-time relationship test results
        print("\n3. Variance-Time Relationship:")
        print(f"   Slope (Log-Log): {results['variance_time']['slope']:.4f}")
        print(f"   R-squared: {results['variance_time']['r_squared']:.4f}")
        print(f"   Deviation from Theoretical Value (1.0): {results['variance_time']['deviation_from_theory']:.4f}")

        # 4. Random walk test results
        print("\n4. Random Walk Test (ADF Test):")
        print(f"   ADF Statistic: {results['random_walk']['adf_statistic']:.4f}")
        print(f"   p-value: {results['random_walk']['adf_p_value']:.6f}")
        print(f"   Critical Values: 1%={results['random_walk']['critical_values']['1%']:.4f}, 5%={results['random_walk']['critical_values']['5%']:.4f}, 10%={results['random_walk']['critical_values']['10%']:.4f}")
        print(f"   Is Random Walk: {'Yes' if results['random_walk']['is_random_walk'] else 'No'}")

        # 5. Hurst exponent
        print(f"\n5. Hurst Exponent: {results['hurst_exponent']:.4f}")
        if results['hurst_exponent'] > 0.5:
            print("   Interpretation: Persistent series (positive autocorrelation)")
        elif results['hurst_exponent'] < 0.5:
            print("   Interpretation: Anti-persistent series (negative autocorrelation)")
        else:
            print("   Interpretation: True random walk (no autocorrelation)")

        # Summary
        print("\n===== Summary =====")
        normality_condition = (results['normality']['shapiro_p_value'] > 0.05 or
                              results['normality']['jb_p_value'] > 0.05)
        autocorrelation_condition = results['autocorrelation']['lb_p_value'] > 0.05
        variance_time_condition = abs(results['variance_time']['slope'] - 1.0) < 0.1
        random_walk_condition = results['random_walk']['is_random_walk']
        hurst_condition = abs(results['hurst_exponent'] - 0.5) < 0.05

        conditions = [normality_condition, autocorrelation_condition,
                     variance_time_condition, random_walk_condition, hurst_condition]

        print(f"Conditions met: {sum(conditions)} out of 5")
        print(f"1. Returns are normally distributed: {'Yes' if normality_condition else 'No'}")
        print(f"2. No autocorrelation in returns: {'Yes' if autocorrelation_condition else 'No'}")
        print(f"3. Variance scales linearly with time: {'Yes' if variance_time_condition else 'No'}")
        print(f"4. Price series follows a random walk: {'Yes' if random_walk_condition else 'No'}")
        print(f"5. Hurst exponent is close to 0.5: {'Yes' if hurst_condition else 'No'}")

        if sum(conditions) >= 4:
            print("\nConclusion: The price series STRONGLY resembles a Brownian motion.")
        elif sum(conditions) >= 3:
            print("\nConclusion: The price series MODERATELY resembles a Brownian motion.")
        else:
            print("\nConclusion: The price series does NOT closely resemble a Brownian motion.")

def run_simulation_and_get_price_data(days=1000, random_seeds=None, enable_trade_log=False):
    """
    Run simulation and get price data

    Parameters:
        days: Number of simulation days
        random_seeds: Random seed dictionary
        enable_trade_log: Whether to enable trade log

    Returns:
        dict: Dictionary containing price data and other related data
    """
    # Import necessary modules
    import sys
    import os
    import importlib.util

    # Get current script directory
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # Build path to main_OHLC_2.0.5.1.py
    module_path = os.path.join(current_dir, 'main_OHLC_2.0.5.1.py')

    # Check if file exists
    if not os.path.exists(module_path):
        raise FileNotFoundError(f"Module file not found: {module_path}")

    # Dynamically import module
    spec = importlib.util.spec_from_file_location("main_OHLC_2_0_5_1", module_path)
    module = importlib.util.module_from_spec(spec)
    sys.modules["main_OHLC_2_0_5_1"] = module
    spec.loader.exec_module(module)

    # Get necessary functions and classes
    simulate_stock_market = module.simulate_stock_market
    generate_random_seeds = module.generate_random_seeds
    Market = module.Market
    TrueValueCurve = module.TrueValueCurve

    # If no random seeds provided, use default seeds
    if random_seeds is None:
        random_seeds = {
            'base_seed': 2108,
            'value_line_seed': 2102,
            'close_seed': 2109,
            'market_seed': 2111,
            'value_investor_seed': 2121,
            'chase_investor_seed': 2111,
            'trend_investor_seed': 2113,
            'random_investor_seed': 2114,
            'never_stop_loss_investor_seed': 2115,
            'bottom_fishing_investor_seed': 2116,
            'insider_investor_seed': 2117,
            'message_investor_seed': 2118
        }

    # Create value curve
    value_curve = TrueValueCurve(initial_value=100, days=days, seed=random_seeds['value_line_seed'])

    # Create market instance
    market = Market(initial_price=100, price_tick=0.01, value_curve=value_curve,
                   seed=random_seeds['market_seed'],
                   close_seed=random_seeds['close_seed'],
                   buy_fee_rate=0.001, sell_fee_rate=0.001)

    # Create investors and run simulation
    # Note: We don't run the complete simulation, but directly generate price data
    # We only care if the price conforms to Brownian motion characteristics, not investor interactions

    # Generate price series
    for _ in range(days):
        # Update market sentiment
        market.update_market_sentiment()

        # Generate daily price
        current_day = len(market.price_history) - 1
        last_price = market.price_history[-1]

        # Generate random price change
        price_change = market._rng.normal(0, 0.01) * last_price
        new_price = max(0.01, last_price + price_change)

        # Update market state
        market.price = new_price
        market.price_history.append(new_price)

        # Update volume
        volume = market._rng.randint(1000, 5000)
        market.executed_volume = volume
        market.executed_volume_history.append(volume)

        # Update OHLC data
        open_price = last_price
        high_price = max(open_price, new_price) * (1 + market._rng.uniform(0, 0.005))
        low_price = min(open_price, new_price) * (1 - market._rng.uniform(0, 0.005))
        close_price = new_price

        if not hasattr(market, 'ohlc_data'):
            market.ohlc_data = []
        market.ohlc_data.append((open_price, high_price, low_price, close_price))

        # Update true value
        if market.value_curve is not None and current_day < len(market.value_curve):
            market.true_value = market.value_curve[current_day]
        market.value_history.append(market.true_value)

    # Extract price data and other related data
    data = {
        'price_history': market.price_history,
        'value_history': market.value_history,
        'ohlc_data': market.ohlc_data if hasattr(market, 'ohlc_data') else None,
        'volume_history': market.executed_volume_history
    }

    return data

def generate_synthetic_brownian_motion(n_steps=1000, mu=0, sigma=0.01, initial_price=100, seed=None):
    """
    Generate synthetic Brownian motion price series

    Parameters:
        n_steps: Number of steps
        mu: Drift term (average change per step)
        sigma: Volatility (standard deviation per step)
        initial_price: Initial price
        seed: Random seed

    Returns:
        numpy.ndarray: Price series
    """
    if seed is not None:
        np.random.seed(seed)

    # Generate normally distributed random increments
    increments = np.random.normal(mu, sigma, n_steps)

    # Calculate log prices
    log_prices = np.cumsum(increments)

    # Convert to prices
    prices = initial_price * np.exp(log_prices)

    # Add initial price
    prices = np.insert(prices, 0, initial_price)

    return prices

def main():
    """Main function"""
    print("Brownian Motion Test Program - Brownian Motion Test Program")
    print("====================================================")

    # 1. Generate synthetic Brownian motion price series as benchmark - use longer steps for more accurate results
    print("\nGenerating synthetic Brownian motion price series...")
    synthetic_prices = generate_synthetic_brownian_motion(n_steps=2000, mu=0.0005, sigma=0.01, initial_price=100, seed=42)

    # 2. Create test object for synthetic data
    synthetic_test = BrownianMotionTest(synthetic_prices, title="Synthetic Brownian Motion")

    # 3. Run all tests and print results
    print("\nTesting synthetic Brownian motion data...")
    synthetic_results = synthetic_test.run_all_tests()
    synthetic_test.print_results(synthetic_results)

    # 4. Visualize synthetic data
    print("\nPlotting synthetic Brownian motion data charts...")
    synthetic_test.plot_price_series()
    synthetic_test.plot_returns()
    synthetic_test.plot_qq()
    synthetic_test.plot_autocorrelation()
    synthetic_test.plot_variance_time()

    # 5. Get price data from main_OHLC_2.0.5.1.py
    print("\nGetting price data from simulation...")
    try:
        # Set random seeds
        random_seeds = {
            'base_seed': 2108,
            'value_line_seed': 2102,
            'close_seed': 2109,
            'market_seed': 2111,
            'value_investor_seed': 2121,
            'chase_investor_seed': 2111,
            'trend_investor_seed': 2113,
            'random_investor_seed': 2114,
            'never_stop_loss_investor_seed': 2115,
            'bottom_fishing_investor_seed': 2116,
            'insider_investor_seed': 2117,
            'message_investor_seed': 2118
        }

        # Run simulation and get price data - use longer days for more accurate results
        data = run_simulation_and_get_price_data(days=2000, random_seeds=random_seeds, enable_trade_log=False)

        # Extract price data
        simulated_prices = data['price_history']

        # 6. Create test object for simulated data
        simulated_test = BrownianMotionTest(simulated_prices, title="Simulated Stock Prices")

        # 7. Run all tests and print results
        print("\nTesting simulated stock price data...")
        simulated_results = simulated_test.run_all_tests()
        simulated_test.print_results(simulated_results)

        # 8. Visualize simulated data
        print("\nPlotting simulated stock price data charts...")
        simulated_test.plot_price_series()
        simulated_test.plot_returns()
        simulated_test.plot_qq()
        simulated_test.plot_autocorrelation()
        simulated_test.plot_variance_time()

        # 9. Compare true value curve and price curve
        print("\nComparing true value curve and price curve...")
        plt.figure(figsize=(12, 6))
        plt.plot(simulated_prices, label='Price')
        plt.plot(data['value_history'], label='True Value', linestyle='--')
        plt.title("Price vs True Value")
        plt.xlabel("Time")
        plt.ylabel("Value")
        plt.legend()
        plt.grid(True)
        plt.show()

    except Exception as e:
        print(f"Unable to get price data from simulation: {e}")
        print("Please ensure main_OHLC_2.0.5.1.py file is available.")

if __name__ == "__main__":
    main()
